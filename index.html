<!DOCTYPE html>
<html>
<head>
<title>Funkin' Trainer</title>
<meta charset="UTF-8">
</head>
<body style="margin:0; background:black;">

<canvas id="game" width="800" height="600"></canvas>

<script>

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let currentState = null;
let songStartTime = 0;
let playbackSpeed = 1.0;

const Input = {
    keys: {},
    prev: {},

    init() {
        window.addEventListener("keydown", e => this.keys[e.key] = true);
        window.addEventListener("keyup", e => this.keys[e.key] = false);
    },

    update() {
        this.prev = { ...this.keys };
    },

    justPressed(key) {
        return this.keys[key] && !this.prev[key];
    }
};

Input.init();

const Renderer = {
    clear() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    },

    drawText(text, x, y, size = 24, color = "white") {
        ctx.fillStyle = color;
        ctx.font = size + "px Arial";
        ctx.fillText(text, x, y);
    },

    drawArena() {
        ctx.fillStyle = "#222";
        ctx.fillRect(0, 500, canvas.width, 10);

        for (let i = 0; i < 4; i++) {
            ctx.fillStyle = "#333";
            ctx.fillRect(150 + i * 100, 0, 80, canvas.height);
        }
    },

    drawNote(lane, y) {
        ctx.fillStyle = "cyan";
        ctx.fillRect(150 + lane * 100, y, 80, 20);
    }
};

function getSongTime() {
    return (performance.now() - songStartTime) * playbackSpeed;
}

const judgeWindows = {
    sick: 45,
    good: 90,
    bad: 135,
    shit: 160
};

function judgeNotePress(note, pressTime) {
    const diff = Math.abs(pressTime - note.time);

    if (diff <= judgeWindows.sick) return "SICK";
    if (diff <= judgeWindows.good) return "GOOD";
    if (diff <= judgeWindows.bad) return "BAD";
    return "SHIT";
}

const SongLoader = {
    async load(path) {
        const res = await fetch(path);
        return await res.json();
    }
};

const MenuState = {
    selected: 0,
    options: ["PLAY", "SETTINGS"],

    init() {},

    update() {
        if (Input.justPressed("ArrowUp")) this.selected--;
        if (Input.justPressed("ArrowDown")) this.selected++;

        this.selected = (this.selected + this.options.length) % this.options.length;

        if (Input.justPressed("Enter")) {
            if (this.selected === 0) changeState(SongSelectState);
            if (this.selected === 1) changeState(SettingsState);
        }
    },

    render() {
        Renderer.clear();
        Renderer.drawText("TRAINER", 300, 150, 48);

        this.options.forEach((opt, i) => {
            Renderer.drawText(
                (i === this.selected ? "> " : "") + opt,
                330,
                250 + i * 40,
                32
            );
        });
    }
};

const SongSelectState = {
    index: 0,
    songs: ["songs/song1.json", "songs/song2.json", "songs/song3.json"],

    init() {},

    update() {
        if (Input.justPressed("ArrowLeft")) this.index--;
        if (Input.justPressed("ArrowRight")) this.index++;

        this.index = (this.index + this.songs.length) % this.songs.length;

        if (Input.justPressed("Enter")) {
            SongLoader.load(this.songs[this.index]).then(data => {
                GameplayState.loadSong(data);
                changeState(GameplayState);
            });
        }
    },

    render() {
        Renderer.clear();
        Renderer.drawText("SELECT SONG", 280, 150, 48);
        Renderer.drawText(this.songs[this.index], 200, 300, 28);
    }
};

const SettingsState = {
    init() {},

    update() {
        if (Input.justPressed("Escape")) changeState(MenuState);
    },

    render() {
        Renderer.clear();
        Renderer.drawText("SETTINGS (WIP)", 250, 200, 40);
        Renderer.drawText("Press ESC to return", 260, 300, 24);
    }
};

const GameplayState = {
    notes: [],
    bpm: 0,
    speed: 1.0,

    lastJudge: "",
    judgeTimer: 0,

    loadSong(data) {
        this.notes = data.notes;
        this.bpm = data.bpm;
        this.speed = data.speed || 1.0;

        songStartTime = performance.now();
    },

    update() {
        const t = getSongTime();

if (Input.justPressed("ArrowLeft"))  this.tryHit(0, t);
if (Input.justPressed("ArrowDown"))  this.tryHit(1, t);
if (Input.justPressed("ArrowUp"))    this.tryHit(2, t);
if (Input.justPressed("ArrowRight")) this.tryHit(3, t);
      
if (Input.justPressed("d")) this.tryHit(0, t);
if (Input.justPressed("f")) this.tryHit(1, t);
if (Input.justPressed("j")) this.tryHit(2, t);
if (Input.justPressed("k")) this.tryHit(3, t);

if (Input.justPressed("z")) this.tryHit(0, t);
if (Input.justPressed("x")) this.tryHit(1, t);
if (Input.justPressed(",")) this.tryHit(2, t);
if (Input.justPressed(".")) this.tryHit(3, t);


        if (this.judgeTimer > 0) {
            this.judgeTimer -= 16;
        }
    },

    tryHit(lane, t) {
        const note = this.notes.find(n => n.lane === lane && !n.hit);
        if (!note) return;

        const result = judgeNotePress(note, t);
        note.hit = true;

        this.lastJudge = result;
        this.judgeTimer = 300;

        console.log(result);
    },

    render() {
        Renderer.clear();
        Renderer.drawArena();

        const t = getSongTime();

        this.notes.forEach(note => {
            if (note.hit) return;

            const timeUntilHit = note.time - t;
            const y = 500 - timeUntilHit * 0.3;

            Renderer.drawNote(note.lane, y);
        });

        if (this.judgeTimer > 0) {
            Renderer.drawText(
                this.lastJudge,
                360,
                300,
                48,
                this.lastJudge === "SICK" ? "cyan" :
                this.lastJudge === "GOOD" ? "green" :
                this.lastJudge === "BAD"  ? "yellow" :
                "red"
            );
        }
    }
};

function changeState(state) {
    currentState = state;
    currentState.init();
}

function gameLoop() {
    Input.update();
    currentState.update();
    currentState.render();
    requestAnimationFrame(gameLoop);
}

changeState(MenuState);
gameLoop();

</script>

</body>
</html>
