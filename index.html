<!DOCTYPE html>
<html>
<head>
<title>Funkin' Trainer</title>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<meta charset="UTF-8">
<style>
    body { margin: 0; background: black; }
</style>
</head>
<body>

<canvas id="game" width="800" height="600" tabindex="1"></canvas>

<script>

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

window.addEventListener("keydown", e => {
    const block = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "];
    if (block.includes(e.key)) e.preventDefault();
}, { passive: false });

window.onload = () => canvas.focus();

let currentState = null;
let songStartTime = 0;

const Input = {
    keys: {},
    prev: {},

    init() {
        window.addEventListener("keydown", e => this.keys[e.key] = true);
        window.addEventListener("keyup", e => this.keys[e.key] = false);
    },

    update() {
        this.prev = { ...this.keys };
    },

    justPressed(key) {
        return this.keys[key] && !this.prev[key];
    }
};

Input.init();

const SettingsState = {
    speed: 1.0, // GLOBAL TIME SCALE

    init() {},

    update() {
        if (Input.justPressed("ArrowLeft")) this.speed = Math.max(0.1, this.speed - 0.1);
        if (Input.justPressed("ArrowRight")) this.speed = Math.min(3.0, this.speed + 0.1);

        if (Input.justPressed("Escape")) changeState(MenuState);
    },

    render() {
        Renderer.clear();
        Renderer.drawText("SETTINGS", 300, 150, 48);
        Renderer.drawText("Scroll Speed (Time Scale): " + this.speed.toFixed(1), 200, 260, 32);
        Renderer.drawText("Left/Right to change", 260, 300, 24);
        Renderer.drawText("Press ESC to return", 260, 340, 24);
    }
};

const assets = {
    arrows: {
        left: new Image(),
        down: new Image(),
        up: new Image(),
        right: new Image()
    },
    receptors: {
        left: new Image(),
        down: new Image(),
        up: new Image(),
        right: new Image()
    }
};

assets.arrows.left.src = "assets/left.png";
assets.arrows.down.src = "assets/down.png";
assets.arrows.up.src = "assets/up.png";
assets.arrows.right.src = "assets/right.png";

assets.receptors.left.src = "assets/left_judgement.png";
assets.receptors.down.src = "assets/down_judgement.png";
assets.receptors.up.src = "assets/up_judgement.png";
assets.receptors.right.src = "assets/right_judgement.png";

const Renderer = {
    clear() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    },

    drawReceptors() {
        const lanes = ["left", "down", "up", "right"];
        for (let i = 0; i < 4; i++) {
            const img = assets.receptors[lanes[i]];
            if (img.complete) ctx.drawImage(img, 150 + i * 100, 100, 80, 80);
        }
    },

    drawNote(lane, y) {
        const lanes = ["left", "down", "up", "right"];
        const img = assets.arrows[lanes[lane]];
        if (img.complete) ctx.drawImage(img, 150 + lane * 100, y, 80, 80);
    },

    drawText(text, x, y, size = 24, color = "white") {
        ctx.font = `${size}px "VT323"`;
        ctx.textBaseline = "top";
        ctx.lineWidth = 6;
        ctx.strokeStyle = "black";
        ctx.strokeText(text, x, y);
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
    }
};

function getSongTime() {
    return (performance.now() - songStartTime) * SettingsState.speed;
}

// JUDGEMENT WINDOWS IN BEATS (fractions of a beat)
const judgeWindows = {
    sick: 0.09,
    good: 0.18,
    bad: 0.27,
    shit: 0.32
};

function judgeNotePress(note, pressTime, bpm) {
    const msPerBeat = 60000 / bpm;
    const diff = Math.abs(pressTime - note.time);

    if (diff <= judgeWindows.sick * msPerBeat) return "SICK";
    if (diff <= judgeWindows.good * msPerBeat) return "GOOD";
    if (diff <= judgeWindows.bad  * msPerBeat) return "BAD";
    return "SHIT";
}

const SongLoader = {
    async load(path) {
        const res = await fetch(path);
        return await res.json();
    }
};

const MenuState = {
    selected: 0,
    options: ["PLAY", "SETTINGS"],

    init() {},

    update() {
        if (Input.justPressed("ArrowUp")) this.selected--;
        if (Input.justPressed("ArrowDown")) this.selected++;

        this.selected = (this.selected + this.options.length) % this.options.length;

        if (Input.justPressed("Enter")) {
            if (this.selected === 0) changeState(SongSelectState);
            if (this.selected === 1) changeState(SettingsState);
        }
    },

    render() {
        Renderer.clear();
        Renderer.drawText("TRAINER", 300, 150, 48);

        this.options.forEach((opt, i) => {
            Renderer.drawText(
                (i === this.selected ? "> " : "") + opt,
                330,
                250 + i * 40,
                32
            );
        });
    }
};

const SongSelectState = {
    index: 0,
    songs: [
        { file: "songs/song1.json", name: "Song Test" },
        { file: "songs/song2.json", name: "Song 2" },
        { file: "songs/song3.json", name: "Song 3" }
    ],

    init() {},

    update() {
        if (Input.justPressed("ArrowUp")) this.index--;
        if (Input.justPressed("ArrowDown")) this.index++;

        this.index = (this.index + this.songs.length) % this.songs.length;

        if (Input.justPressed("Enter")) {
            const songFile = this.songs[this.index].file;

            LoadingState.task = async () => {
                const data = await SongLoader.load(songFile);
                GameplayState.loadSong(data);
            };

            changeState(LoadingState);
        }
    },

    render() {
        Renderer.clear();
        Renderer.drawText("SELECT SONG", 280, 100, 48);

        this.songs.forEach((song, i) => {
            const isSelected = (i === this.index);
            Renderer.drawText(
                (isSelected ? "> " : "  ") + song.name,
                200,
                200 + (i * 50),
                isSelected ? 32 : 24,
                isSelected ? "cyan" : "white"
            );
        });
    }
};

const LoadingState = {
    message: "Loading...",
    task: null,

    init() {
        this.message = "Loading...";

        this.task()
            .then(() => changeState(GameplayState))
            .catch(err => {
                console.error(err);
                this.message = "Failed to load!";
            });
    },

    update() {},

    render() {
        Renderer.clear();
        Renderer.drawText(this.message, 300, 250, 48);
    }
};

const GameplayState = {
    notes: [],
    bpm: 0,

    lastJudge: "",
    judgeTimer: 0,

    loadSong(data) {
        this.notes = data.notes;
        this.bpm = data.bpm;
        songStartTime = performance.now();
    },

    update() {
        const t = getSongTime();

        const hit = (lane) => this.tryHit(lane, t);

        if (Input.justPressed("ArrowLeft")) hit(0);
        if (Input.justPressed("ArrowDown")) hit(1);
        if (Input.justPressed("ArrowUp")) hit(2);
        if (Input.justPressed("ArrowRight")) hit(3);

        if (Input.justPressed("d")) hit(0);
        if (Input.justPressed("f")) hit(1);
        if (Input.justPressed("j")) hit(2);
        if (Input.justPressed("k")) hit(3);

        if (Input.justPressed("z")) hit(0);
        if (Input.justPressed("x")) hit(1);
        if (Input.justPressed(",")) hit(2);
        if (Input.justPressed(".")) hit(3);

        if (this.judgeTimer > 0) this.judgeTimer -= 16;
    },

    tryHit(lane, t) {
        const note = this.notes.find(n => n.lane === lane && !n.hit);
        if (!note) return;

        const result = judgeNotePress(note, t, this.bpm);
        note.hit = true;

        this.lastJudge = result;
        this.judgeTimer = 300;
    },

    render() {
        Renderer.clear();
        Renderer.drawReceptors();

        const t = getSongTime();

        this.notes.forEach(note => {
            if (note.hit) return;

            const timeUntilHit = note.time - t;
            const y = 500 + timeUntilHit * 0.3;

            Renderer.drawNote(note.lane, y);
        });

        if (this.judgeTimer > 0) {
            Renderer.drawText(
                this.lastJudge,
                360,
                200,
                48,
                this.lastJudge === "SICK" ? "cyan" :
                this.lastJudge === "GOOD" ? "green" :
                this.lastJudge === "BAD"  ? "yellow" :
                "red"
            );
        }
    }
};

function changeState(state) {
    currentState = state;
    currentState.init();
}

function gameLoop() {
    currentState.update();
    currentState.render();
    Input.update();
    requestAnimationFrame(gameLoop);
}

changeState(MenuState);
gameLoop();

</script>

</body>
</html>
