<!DOCTYPE html>
<html>
<head>
<title>Funkin' Trainer</title>
<meta charset="UTF-8">
<style>
    body { margin: 0; background: black; }
</style>
</head>
<body>

<canvas id="game" width="800" height="600"></canvas>

<script>

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let currentState = null;
let songStartTime = 0;


const Input = {
    keys: {},
    prev: {},

    init() {
        window.addEventListener("keydown", e => this.keys[e.key] = true);
        window.addEventListener("keyup", e => this.keys[e.key] = false);
    },

    update() {
        this.prev = { ...this.keys };
    },

    justPressed(key) {
        return this.keys[key] && !this.prev[key];
    }
};

Input.init();

const assets = {
    arrows: {
        left: new Image(),
        down: new Image(),
        up: new Image(),
        right: new Image()
    },
    receptors: {
        left: new Image(),
        down: new Image(),
        up: new Image(),
        right: new Image()
    }
};

assets.arrows.left.src = "assets/left.png";
assets.arrows.down.src = "assets/down.png";
assets.arrows.up.src = "assets/up.png";
assets.arrows.right.src = "assets/right.png";

assets.receptors.left.src = "assets/left_judgement.png";
assets.receptors.down.src = "assets/down_judgement.png";
assets.receptors.up.src = "assets/up_judgement.png";
assets.receptors.right.src = "assets/right_judgement.png";

const Renderer = {
    clear() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    },

    drawReceptors() {
        const lanes = ["left", "down", "up", "right"];

        for (let i = 0; i < 4; i++) {
            const img = assets.receptors[lanes[i]];
            if (img.complete) {
                ctx.drawImage(img, 150 + i * 100, 100, 80, 80);
            }
        }
    },

    drawNote(lane, y) {
        const lanes = ["left", "down", "up", "right"];
        const img = assets.arrows[lanes[lane]];

        if (img.complete) {
            ctx.drawImage(img, 150 + lane * 100, y, 80, 80);
        }
    },

    drawText(text, x, y, size = 24, color = "white") {
        ctx.fillStyle = color;
        ctx.font = size + "px Arial";
        ctx.fillText(text, x, y);
    }
};

function getSongTime() {
    return performance.now() - songStartTime;
}

const judgeWindows = {
    sick: 45,
    good: 90,
    bad: 135,
    shit: 160
};

function judgeNotePress(note, pressTime) {
    const diff = Math.abs(pressTime - note.time);

    if (diff <= judgeWindows.sick) return "SICK";
    if (diff <= judgeWindows.good) return "GOOD";
    if (diff <= judgeWindows.bad) return "BAD";
    return "SHIT";
}


const SongLoader = {
    async load(path) {
        const res = await fetch(path);
        return await res.json();
    }
};

const MenuState = {
    selected: 0,
    options: ["PLAY", "SETTINGS"],

    init() {},

    update() {
        if (Input.justPressed("ArrowUp")) this.selected--;
        if (Input.justPressed("ArrowDown")) this.selected++;

        this.selected = (this.selected + this.options.length) % this.options.length;

        if (Input.justPressed("Enter")) {
            if (this.selected === 0) changeState(SongSelectState);
            if (this.selected === 1) changeState(SettingsState);
        }
    },

    render() {
        Renderer.clear();
        Renderer.drawText("TRAINER", 300, 150, 48);

        this.options.forEach((opt, i) => {
            Renderer.drawText(
                (i === this.selected ? "> " : "") + opt,
                330,
                250 + i * 40,
                32
            );
        });
    }
};

const SongSelectState = {
    index: 0,
    songs: ["songs/song1.json"],

    init() {},

    update() {
        if (Input.justPressed("ArrowLeft")) this.index--;
        if (Input.justPressed("ArrowRight")) this.index++;

        this.index = (this.index + this.songs.length) % this.songs.length;

        if (Input.justPressed("Enter")) {
            SongLoader.load(this.songs[this.index]).then(data => {
                GameplayState.loadSong(data);
                changeState(GameplayState);
            });
        }
    },

    render() {
        Renderer.clear();
        Renderer.drawText("SELECT SONG", 280, 150, 48);
        Renderer.drawText(this.songs[this.index], 200, 300, 28);
    }
};

const SettingsState = {
    init() {},

    update() {
        if (Input.justPressed("Escape")) changeState(MenuState);
    },

    render() {
        Renderer.clear();
        Renderer.drawText("SETTINGS (WIP)", 250, 200, 40);
        Renderer.drawText("Press ESC to return", 260, 300, 24);
    }
};

const GameplayState = {
    notes: [],
    bpm: 0,

    lastJudge: "",
    judgeTimer: 0,

    loadSong(data) {
        this.notes = data.notes;
        this.bpm = data.bpm;

        songStartTime = performance.now();
    },

    update() {
        const t = getSongTime();

        // Arrow keys
        if (Input.justPressed("ArrowLeft"))  this.tryHit(0, t);
        if (Input.justPressed("ArrowDown"))  this.tryHit(1, t);
        if (Input.justPressed("ArrowUp"))    this.tryHit(2, t);
        if (Input.justPressed("ArrowRight")) this.tryHit(3, t);

        // DFJK
        if (Input.justPressed("d")) this.tryHit(0, t);
        if (Input.justPressed("f")) this.tryHit(1, t);
        if (Input.justPressed("j")) this.tryHit(2, t);
        if (Input.justPressed("k")) this.tryHit(3, t);

        // ZX,.
        if (Input.justPressed("z")) this.tryHit(0, t);
        if (Input.justPressed("x")) this.tryHit(1, t);
        if (Input.justPressed(",")) this.tryHit(2, t);
        if (Input.justPressed(".")) this.tryHit(3, t);

        if (this.judgeTimer > 0) this.judgeTimer -= 16;
    },

    tryHit(lane, t) {
        const note = this.notes.find(n => n.lane === lane && !n.hit);
        if (!note) return;

        const result = judgeNotePress(note, t);
        note.hit = true;

        this.lastJudge = result;
        this.judgeTimer = 300;
    },

    render() {
        Renderer.clear();
        Renderer.drawReceptors();

        const t = getSongTime();

        this.notes.forEach(note => {
            if (note.hit) return;

            const timeUntilHit = note.time - t;
            const y = 500 + timeUntilHit * 0.3;

            Renderer.drawNote(note.lane, y);
        });

        if (this.judgeTimer > 0) {
            Renderer.drawText(
                this.lastJudge,
                360,
                200,
                48,
                this.lastJudge === "SICK" ? "cyan" :
                this.lastJudge === "GOOD" ? "green" :
                this.lastJudge === "BAD"  ? "yellow" :
                "red"
            );
        }
    }
};

function changeState(state) {
    currentState = state;
    currentState.init();
}

function gameLoop() {
    currentState.update();
    currentState.render();
    Input.update();
    requestAnimationFrame(gameLoop);
}


changeState(MenuState);
gameLoop();

</script>

</body>
</html>
