<!DOCTYPE html>
<html>
<head>
<title>Funkin' Trainer</title>
<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<meta charset="UTF-8">
<style>
    body { margin: 0; background: black; }
</style>
</head>
<body>

<canvas id="game" width="800" height="600" tabindex="1"></canvas>

<script>

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

window.addEventListener("keydown", e => {
    const block = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "];
    if (block.includes(e.key)) e.preventDefault();
}, { passive: false });

window.onload = () => canvas.focus();

let currentState = null;
let songStartTime = 0;

const Input = {
    keys: {},
    prev: {},

    init() {
        window.addEventListener("keydown", e => this.keys[e.key] = true);
        window.addEventListener("keyup", e => this.keys[e.key] = false);
    },

    update() {
        this.prev = { ...this.keys };
    },

    justPressed(key) {
        return this.keys[key] && !this.prev[key];
    }
};

Input.init();

const SettingsState = {
    speed: 1.0,

    init() {},

    update() {
        if (Input.justPressed("ArrowLeft")) this.speed = Math.max(0.1, this.speed - 0.1);
        if (Input.justPressed("ArrowRight")) this.speed = Math.min(3.0, this.speed + 0.1);

        if (Input.justPressed("Escape")) changeState(MenuState);
    },

    render() {
        Renderer.clear();
        Renderer.drawText("SETTINGS", 300, 150, 48);
        Renderer.drawText("Scroll Speed (Time Scale): " + this.speed.toFixed(1), 200, 260, 32);
        Renderer.drawText("Left/Right to change", 260, 300, 24);
        Renderer.drawText("Press ESC to return", 260, 340, 24);
    }
};

const assets = {
    arrows: {
        left: new Image(),
        down: new Image(),
        up: new Image(),
        right: new Image()
    },
    receptors: {
        left: new Image(),
        down: new Image(),
        up: new Image(),
        right: new Image()
    }
};

assets.arrows.left.src = "assets/left.png";
assets.arrows.down.src = "assets/down.png";
assets.arrows.up.src = "assets/up.png";
assets.arrows.right.src = "assets/right.png";

assets.receptors.left.src = "assets/left_judgement.png";
assets.receptors.down.src = "assets/down_judgement.png";
assets.receptors.up.src = "assets/up_judgement.png";
assets.receptors.right.src = "assets/right_judgement.png";

const Renderer = {
    clear() {
        ctx.fillStyle = "black";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    },

    drawReceptors() {
        const lanes = ["left", "down", "up", "right"];
        for (let i = 0; i < 4; i++) {
            const img = assets.receptors[lanes[i]];
            if (img.complete) ctx.drawImage(img, 150 + i * 100, 100, 80, 80);
        }
    },

    drawNote(lane, y) {
        const lanes = ["left", "down", "up", "right"];
        const img = assets.arrows[lanes[lane]];
        if (img.complete) ctx.drawImage(img, 150 + lane * 100, y, 80, 80);
    },

    drawText(text, x, y, size = 24, color = "white") {
        ctx.font = `${size}px "VT323"`;
        ctx.textBaseline = "top";
        ctx.lineWidth = 6;
        ctx.strokeStyle = "black";
        ctx.strokeText(text, x, y);
        ctx.fillStyle = color;
        ctx.fillText(text, x, y);
    }
};

function getSongTime() {
    return (performance.now() - songStartTime) * SettingsState.speed;
}

const judgeWindows = {
    sick: 45, 
    good: 90,
    bad: 135,
    shit: 160
};

function judgeNotePress(note, pressTime) {
    const diff = Math.abs(pressTime - note.time);
    if (diff <= judgeWindows.sick) return "SICK";
    if (diff <= judgeWindows.good) return "GOOD";
    if (diff <= judgeWindows.bad)  return "BAD";
    return "SHIT";
}

const SongLoader = {
    async load(path) {
        const res = await fetch(path);
        return await res.json();
    }
};

const MenuState = {
    selected: 0,
    options: ["PLAY", "SETTINGS"],

    init() {},

    update() {
        if (Input.justPressed("ArrowUp")) this.selected--;
        if (Input.justPressed("ArrowDown")) this.selected++;

        this.selected = (this.selected + this.options.length) % this.options.length;

        if (Input.justPressed("Enter")) {
            if (this.selected === 0) changeState(SongSelectState);
            if (this.selected === 1) changeState(SettingsState);
        }
    },

    render() {
        Renderer.clear();
        Renderer.drawText("FUNKY TRAINER", 300, 150, 48);

        this.options.forEach((opt, i) => {
            Renderer.drawText(
                (i === this.selected ? "> " : "") + opt,
                330,
                250 + i * 40,
                32
            );
        });
    }
};

const SongSelectState = {
    index: 0,
    songs: [
        { file: "songs/song1.json", name: "Spookeez (Nightmare)" },
        { file: "songs/song2.json", name: "Song 2" },
        { file: "songs/song3.json", name: "Song 3" }
    ],

    init() {},

    update() {
        if (Input.justPressed("ArrowUp")) this.index--;
        if (Input.justPressed("ArrowDown")) this.index++;

        this.index = (this.index + this.songs.length) % this.songs.length;

        if (Input.justPressed("Escape")) {
        changeState(MenuState);
    }

        if (Input.justPressed("Enter")) {
            const songFile = this.songs[this.index].file;

            LoadingState.task = async () => {
                const data = await SongLoader.load(songFile);
                GameplayState.loadSong(data);
            };

            changeState(LoadingState);
        }
    },

    render() {
        Renderer.clear();
        Renderer.drawText("SELECT SONG", 280, 100, 48);

        this.songs.forEach((song, i) => {
            const isSelected = (i === this.index);
            Renderer.drawText(
                (isSelected ? "> " : "  ") + song.name,
                200,
                200 + (i * 50),
                isSelected ? 32 : 24,
                isSelected ? "cyan" : "white"
            );
        });
    }
};

const LoadingState = {
    message: "Loading...",
    task: null,

    init() {
        this.message = "Loading...";

        this.task()
            .then(() => changeState(GameplayState))
            .catch(err => {
                console.error(err);
                this.message = "Failed to load!";
            });
    },

    update() {},

    render() {
        Renderer.clear();
        Renderer.drawText(this.message, 300, 250, 48);
    }
};

const ResultsState = {
    sicks: 0,
    goods: 0,
    bads: 0,
    shits: 0,
    misses: 0,

    setResults(game) {
        this.sicks = game.sicks;
        this.goods = game.goods;
        this.bads = game.bads;
        this.shits = game.shits;
        this.misses = game.misses;
    },

    init() {},

    update() {
        if (Input.justPressed("Enter")) {
            changeState(SongSelectState);
        }
    },

    render() {
        Renderer.clear();
        Renderer.drawText("RESULTS", 320, 100, 48);

        Renderer.drawText("SICKS:  " + this.sicks, 300, 200, 32, "cyan");
        Renderer.drawText("GOODS:  " + this.goods, 300, 240, 32, "green");
        Renderer.drawText("BADS:   " + this.bads, 300, 280, 32, "yellow");
        Renderer.drawText("SHITS:  " + this.shits, 300, 320, 32, "red");
        Renderer.drawText("MISSES: " + this.misses, 300, 360, 32, "white");

        Renderer.drawText("Press ENTER to return", 260, 450, 24);
    }
};

const GameplayState = {
    notes: [],
    bpm: 0,

    lastJudge: "",
    judgeTimer: 0,

    sicks: 0,
    goods: 0,
    bads: 0,
    shits: 0,
    misses: 0,

    loadSong(data) {
        this.notes = data.notes;
        this.bpm = data.bpm;

        this.sicks = 0;
        this.goods = 0;
        this.bads = 0;
        this.shits = 0;
        this.misses = 0;

        this.lastJudge = "";
        this.judgeTimer = 0;

        songStartTime = performance.now();
    },

    update() {
        const t = getSongTime();

        const hit = (lane) => this.tryHit(lane, t);

        if (Input.justPressed("ArrowLeft")) hit(0);
        if (Input.justPressed("ArrowDown")) hit(1);
        if (Input.justPressed("ArrowUp")) hit(2);
        if (Input.justPressed("ArrowRight")) hit(3);

        if (Input.justPressed("d")) hit(0);
        if (Input.justPressed("f")) hit(1);
        if (Input.justPressed("j")) hit(2);
        if (Input.justPressed("k")) hit(3);

        if (Input.justPressed("z")) hit(0);
        if (Input.justPressed("x")) hit(1);
        if (Input.justPressed(",")) hit(2);
        if (Input.justPressed(".")) hit(3);

        if (this.judgeTimer > 0) this.judgeTimer -= 16;
        const msPerBeat = 60000 / this.bpm;
const missWindow = judgeWindows.shit * msPerBeat;

this.notes.forEach(note => {
    if (!note.hit && t > (note.time + missWindow)) {
        this.misses++;
    }
});

        if (this.notes.length > 0) {
            const lastNoteTime = this.notes[this.notes.length - 1].time;
            if (t > lastNoteTime + 2000) {
                ResultsState.setResults(this);
                changeState(ResultsState);
            }
        }
    },

    tryHit(lane, t) {
      const msPerBeat = 60000 / this.bpm;
    const maxWindow = judgeWindows.shit * msPerBeat;
    const note = this.notes.find(n => 
        n.lane === lane && 
        !n.hit && 
        Math.abs(t - n.time) <= maxWindow
    );

    if (!note) return;

        const result = judgeNotePress(note, t, this.bpm);

        note.hit = true;

        if (result === "SICK") this.sicks++;
        else if (result === "GOOD") this.goods++;
        else if (result === "BAD") this.bads++;
        else if (result === "SHIT") this.shits++;

        this.lastJudge = result;
        this.judgeTimer = 300;
    },

    render() {
        Renderer.clear();
        Renderer.drawReceptors();

        const t = getSongTime();

        this.notes.forEach(note => {
    if (note.hit) return;

    const scrollSpeed = (this.bpm / 100) * 0.45;
    const y = 100 + (note.time - t) * scrollSpeed;
    if (y > -100 && y < 650) {
        Renderer.drawNote(note.lane, y);
    }
});


        if (this.judgeTimer > 0) {
            Renderer.drawText(
                this.lastJudge,
                360,
                200,
                48,
                this.lastJudge === "SICK" ? "cyan" :
                this.lastJudge === "GOOD" ? "green" :
                this.lastJudge === "BAD"  ? "yellow" :
                "red"
            );
        }
    }
};

function changeState(state) {
    currentState = state;
    currentState.init();
}

function gameLoop() {
    currentState.update();
    currentState.render();
    Input.update();
    requestAnimationFrame(gameLoop);
}

changeState(MenuState);
gameLoop();

</script>

</body>
</html>
